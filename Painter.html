<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Painter app. Paste images, draw, crop, fill, rotate, and export quickly.">
  <title>Painter | HelloAI</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;600;700;800&family=Manrope:wght@500;600;700&family=Space+Grotesk:wght@600;700&family=Sora:wght@600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
  <link rel="stylesheet" href="/painter.css">
</head>
<body class="paint-app">
  <header class="site-header">
    <div class="container nav-row">
      <a class="brand" href="/index.html" aria-label="HelloAI home">
        <img class="brand-logo" src="/media/HelloAI_logo_trim.png" alt="HelloAI logo">
        <span class="brand-word">HelloAI</span>
      </a>
      <nav class="site-nav" aria-label="Main navigation">
        <a href="/index.html">Home</a>
        <a class="active" href="/apps.html">Apps</a>
        <a href="/about.html">About</a>
        <a href="/contact.html">Contact</a>
      </nav>
    </div>
  </header>
  <main class="paint-main">
    <div class="paint-window">
      <div class="paint-titlebar">
        <div class="paint-title">Untitled - Paint</div>
      </div>

      <div class="paint-ribbon" aria-label="Paint ribbon">
        <div class="ribbon-group ribbon-clipboard">
          <div class="ribbon-row">
            <button class="ribbon-btn ribbon-btn--quick ribbon-btn--primary" id="save-png" type="button">Save</button>
            <button class="ribbon-btn ribbon-btn--quick ribbon-btn--icon" id="undo" type="button" aria-label="Undo" title="Undo">
              <svg class="ribbon-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M9 7H4V2"></path>
                <path d="M4 7c3-3 8-3 11 0 3 3 3 8 0 11"></path>
              </svg>
            </button>
            <button class="ribbon-btn ribbon-btn--quick ribbon-btn--icon" id="redo" type="button" aria-label="Redo" title="Redo">
              <svg class="ribbon-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M15 7h5V2"></path>
                <path d="M20 7c-3-3-8-3-11 0-3 3-3 8 0 11"></path>
              </svg>
            </button>
          </div>
          <div class="ribbon-row">
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="select" type="button" aria-label="Select" title="Select">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
                <rect x="4" y="4" width="16" height="16" stroke-dasharray="2.5 2.5"></rect>
              </svg>
            </button>
            <button class="ribbon-btn tool-icon-btn" id="crop-btn" type="button" aria-label="Crop" title="Crop">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 3v11a3 3 0 0 0 3 3h11"></path>
                <path d="M3 7h11a3 3 0 0 1 3 3v11"></path>
              </svg>
            </button>
          </div>
          <div class="ribbon-title">Clipboard</div>
        </div>

        <div class="ribbon-group ribbon-image">
          <div class="ribbon-row">
            <label class="ribbon-label" for="canvas-width">Resize</label>
            <input class="ribbon-input" id="canvas-width" type="number" min="200" value="1200">
            <input class="ribbon-input" id="canvas-height" type="number" min="200" value="720">
            <button class="ribbon-btn" id="resize-canvas" type="button">Apply</button>
          </div>
          <div class="ribbon-row">
            <label class="ribbon-label">Rotate</label>
            <button class="ribbon-btn ribbon-btn--icon" id="rotate-left" type="button" aria-label="Rotate left" title="Rotate left">
              <svg class="ribbon-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 7H3V3"></path>
                <path d="M3 7a9 9 0 1 0 3-3"></path>
              </svg>
            </button>
            <button class="ribbon-btn ribbon-btn--icon" id="rotate-right" type="button" aria-label="Rotate right" title="Rotate right">
              <svg class="ribbon-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M17 7h4V3"></path>
                <path d="M21 7a9 9 0 1 1-3-3"></path>
              </svg>
            </button>
            <button class="ribbon-btn ribbon-btn--icon" id="flip-h" type="button" aria-label="Flip horizontal" title="Flip horizontal">
              <svg class="ribbon-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 4v16"></path>
                <path d="M8 8l-4 4 4 4"></path>
                <path d="M16 8l4 4-4 4"></path>
              </svg>
            </button>
            <button class="ribbon-btn ribbon-btn--icon" id="flip-v" type="button" aria-label="Flip vertical" title="Flip vertical">
              <svg class="ribbon-icon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 12h16"></path>
                <path d="M8 8l4-4 4 4"></path>
                <path d="M8 16l4 4 4-4"></path>
              </svg>
            </button>
          </div>
          <div class="ribbon-title">Image</div>
        </div>

        <div class="ribbon-group ribbon-tools">
          <div class="ribbon-grid">
            <button class="ribbon-btn tool-button tool-icon-btn active" data-tool="brush" type="button" aria-label="Brush" title="Brush">
              <svg class="tool-icon-color" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M6 16l-1 4 4-1 10-10-3-3L6 16z" fill="#f4a640" stroke="#c97b24" stroke-width="0.8" stroke-linejoin="round"></path>
                <path d="M17 5l2 2 1-1-2-2z" fill="#f5d7b3" stroke="#c79a73" stroke-width="0.6" stroke-linejoin="round"></path>
                <path d="M5.2 20.2l1.8-.5-1.3-1.3z" fill="#6b4a2b"></path>
                <rect x="15.2" y="3.4" width="3.3" height="2.2" rx="0.4" transform="rotate(45 16.85 4.5)" fill="#f3a6b6" stroke="#c97a8b" stroke-width="0.6"></rect>
              </svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="pencil" type="button" aria-label="Pencil" title="Pencil">
              <svg class="tool-icon-color" viewBox="0 0 24 24" aria-hidden="true">
                <circle cx="10" cy="10" r="5" fill="#e6eef8" stroke="#4c6fa3" stroke-width="1.4"></circle>
                <circle cx="10" cy="10" r="2.5" fill="none" stroke="#9bb4d8" stroke-width="1"></circle>
                <line x1="14" y1="14" x2="19" y2="19" stroke="#4c6fa3" stroke-width="2" stroke-linecap="round"></line>
              </svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="eraser" type="button" aria-label="Eraser" title="Eraser">
              <svg class="tool-icon-color" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M6 15l6-6 6 6-4 4H10z" fill="#f7a7b6" stroke="#c77a8a" stroke-width="0.8" stroke-linejoin="round"></path>
                <path d="M14 19h6" stroke="#b18484" stroke-width="1.2" stroke-linecap="round"></path>
                <path d="M9 17h6" stroke="#f1c3cc" stroke-width="1.6" stroke-linecap="round"></path>
              </svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="fill" type="button" aria-label="Fill" title="Fill">
              <svg class="tool-icon-color" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 11l6-5 5 5-6 6z" fill="#cfe2f5" stroke="#5c7ea7" stroke-width="0.8" stroke-linejoin="round"></path>
                <path d="M10 8l4 4" stroke="#5c7ea7" stroke-width="1.2" stroke-linecap="round"></path>
                <path d="M17.5 16.5c1.1 1.2 1.8 2.1 1.8 3a2 2 0 0 1-4 0c0-.9.7-1.8 2.2-3z" fill="#f4a640" stroke="#c97b24" stroke-width="0.6"></path>
              </svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="text" type="button" aria-label="Text" title="Text">
              <svg class="tool-icon-color" viewBox="0 0 24 24" aria-hidden="true">
                <text x="6" y="18" font-family="Segoe UI, Arial, sans-serif" font-size="16" font-weight="700" fill="#2a4c7f">A</text>
                <path d="M5 19h14" stroke="#2a4c7f" stroke-width="1" stroke-linecap="round"></path>
              </svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="picker" type="button" aria-label="Color Picker" title="Color Picker">
              <svg class="tool-icon-color" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 16l8-8 3 3-8 8H7z" fill="#cfd8e6" stroke="#5c6f8a" stroke-width="0.8" stroke-linejoin="round"></path>
                <path d="M14 6l3 3" stroke="#5c6f8a" stroke-width="1.2" stroke-linecap="round"></path>
                <circle cx="8.5" cy="17.5" r="2.1" fill="#4aa3df" stroke="#2d6fa4" stroke-width="0.8"></circle>
              </svg>
            </button>
          </div>
          <div class="ribbon-title">Tools</div>
        </div>

        <div class="ribbon-group ribbon-shapes">
          <div class="ribbon-grid shapes-grid">
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="line" type="button" aria-label="Line" title="Line">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M5 19L19 5"></path></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="rect" type="button" aria-label="Rectangle" title="Rectangle">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="6" width="14" height="12"></rect></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="roundrect" type="button" aria-label="Rounded Rectangle" title="Rounded Rectangle">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="6" width="14" height="12" rx="3"></rect></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="ellipse" type="button" aria-label="Ellipse" title="Ellipse">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><ellipse cx="12" cy="12" rx="7" ry="6"></ellipse></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="righttriangle" type="button" aria-label="Right Triangle" title="Right Triangle">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M6 6v12h12z"></path></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="diamond" type="button" aria-label="Diamond" title="Diamond">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 5l7 7-7 7-7-7z"></path></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="pentagon" type="button" aria-label="Pentagon" title="Pentagon">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l7 5-3 9H8L5 9z"></path></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="hexagon" type="button" aria-label="Hexagon" title="Hexagon">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M8 5h8l4 7-4 7H8l-4-7z"></path></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="arrow" type="button" aria-label="Arrow" title="Arrow">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 19L19 4"></path><path d="M12 4h7v7"></path></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="double-arrow" type="button" aria-label="Double Arrow" title="Double Arrow">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M4 12h16"></path><path d="M9 7l-5 5 5 5"></path><path d="M15 7l5 5-5 5"></path></svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="filled-arrow" type="button" aria-label="Block Arrow" title="Block Arrow">
              <svg class="tool-icon tool-icon--filled" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M4 7h9V4l7 8-7 8v-3H4z"></path>
              </svg>
            </button>
            <button class="ribbon-btn tool-button tool-icon-btn" data-tool="star" type="button" aria-label="Star" title="Star">
              <svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l2.3 5 5.4.4-4.2 3.6 1.3 5.4L12 15.6 7.2 18.4l1.3-5.4L4.3 9.4l5.4-.4z"></path></svg>
            </button>
          </div>
          <div class="ribbon-row">
            <label class="ribbon-label" for="outline-mode">Outline</label>
            <select class="ribbon-select" id="outline-mode">
              <option value="solid">Solid</option>
              <option value="none">None</option>
            </select>
            <label class="ribbon-label" for="fill-mode">Fill</label>
            <select class="ribbon-select" id="fill-mode">
              <option value="solid">Solid</option>
              <option value="none">None</option>
            </select>
            <label class="ribbon-label" for="line-style">Line</label>
            <select class="ribbon-select" id="line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
              <option value="dashdot">Dash dot</option>
            </select>
            <label class="ribbon-label" for="arrow-head">Arrow head</label>
            <select class="ribbon-select" id="arrow-head">
              <option value="open">Open</option>
              <option value="filled">Filled</option>
              <option value="diamond">Diamond</option>
            </select>
          </div>
          <div class="ribbon-title">Shapes</div>
        </div>

        <div class="ribbon-group ribbon-size">
          <div class="ribbon-row">
            <label class="ribbon-label">Size</label>
            <div class="size-picker" id="size-picker">
              <button class="size-btn" data-size="2" type="button"></button>
              <button class="size-btn" data-size="4" type="button"></button>
              <button class="size-btn" data-size="8" type="button"></button>
              <button class="size-btn" data-size="12" type="button"></button>
              <button class="size-btn" data-size="16" type="button"></button>
            </div>
          </div>
          <div class="ribbon-row">
            <label class="ribbon-label" for="opacity-range">Opacity</label>
            <input class="ribbon-range" id="opacity-range" type="range" min="10" max="100" value="100">
          </div>
          <div class="ribbon-row">
            <label class="ribbon-label" for="text-size-select">Text size</label>
            <select class="ribbon-select ribbon-select--compact" id="text-size-select">
              <option value="12">12</option>
              <option value="14">14</option>
              <option value="16">16</option>
              <option value="18">18</option>
              <option value="20">20</option>
              <option value="24">24</option>
              <option value="28" selected>28</option>
              <option value="32">32</option>
              <option value="36">36</option>
              <option value="48">48</option>
              <option value="60">60</option>
              <option value="72">72</option>
              <option value="custom">Custom</option>
            </select>
            <input class="ribbon-input ribbon-input--compact" id="text-size-input" type="number" min="6" max="200" value="28">
            <select class="ribbon-select" id="text-font">
              <option value="Segoe UI">Segoe UI</option>
              <option value="Inter">Inter</option>
              <option value="Manrope">Manrope</option>
              <option value="Space Grotesk">Space Grotesk</option>
              <option value="Sora">Sora</option>
              <option value="Arial">Arial</option>
              <option value="Helvetica">Helvetica</option>
              <option value="Verdana">Verdana</option>
              <option value="Tahoma">Tahoma</option>
              <option value="Trebuchet MS">Trebuchet MS</option>
              <option value="Georgia">Georgia</option>
              <option value="Times New Roman">Times New Roman</option>
              <option value="Courier New">Courier New</option>
            </select>
          </div>
          <div class="ribbon-title">Size</div>
        </div>

        <div class="ribbon-group ribbon-colors">
          <div class="ribbon-row ribbon-row--palette">
            <div class="color-stack">
              <div class="color-box">
                <span class="color-label">Color 1</span>
                <button class="color-sample" id="color1-btn" type="button"></button>
                <input id="color1-input" type="color" value="#1f2937" hidden>
              </div>
              <div class="color-box">
                <span class="color-label">Color 2</span>
                <button class="color-sample" id="color2-btn" type="button"></button>
                <input id="color2-input" type="color" value="#f97316" hidden>
              </div>
            </div>
            <div class="palette-column">
              <div class="palette-grid" id="palette-grid">
              <button class="color-chip" style="background:#000000" data-color="#000000" aria-label="Black"></button>
              <button class="color-chip" style="background:#7f7f7f" data-color="#7f7f7f" aria-label="Gray"></button>
              <button class="color-chip" style="background:#880015" data-color="#880015" aria-label="Dark red"></button>
              <button class="color-chip" style="background:#ed1c24" data-color="#ed1c24" aria-label="Red"></button>
              <button class="color-chip" style="background:#ff7f27" data-color="#ff7f27" aria-label="Orange"></button>
              <button class="color-chip" style="background:#fff200" data-color="#fff200" aria-label="Yellow"></button>
              <button class="color-chip" style="background:#22b14c" data-color="#22b14c" aria-label="Green"></button>
              <button class="color-chip" style="background:#00a2e8" data-color="#00a2e8" aria-label="Sky"></button>
              <button class="color-chip" style="background:#3f48cc" data-color="#3f48cc" aria-label="Blue"></button>
              <button class="color-chip" style="background:#a349a4" data-color="#a349a4" aria-label="Purple"></button>
              <button class="color-chip" style="background:#ffffff" data-color="#ffffff" aria-label="White"></button>
              <button class="color-chip" style="background:#c3c3c3" data-color="#c3c3c3" aria-label="Light gray"></button>
              <button class="color-chip" style="background:#b97a57" data-color="#b97a57" aria-label="Brown"></button>
              <button class="color-chip" style="background:#ffaec9" data-color="#ffaec9" aria-label="Pink"></button>
              <button class="color-chip" style="background:#ffc90e" data-color="#ffc90e" aria-label="Gold"></button>
              <button class="color-chip" style="background:#efe4b0" data-color="#efe4b0" aria-label="Beige"></button>
              <button class="color-chip" style="background:#b5e61d" data-color="#b5e61d" aria-label="Lime"></button>
              <button class="color-chip" style="background:#99d9ea" data-color="#99d9ea" aria-label="Light blue"></button>
              <button class="color-chip" style="background:#7092be" data-color="#7092be" aria-label="Steel"></button>
              <button class="color-chip" style="background:#c8bfe7" data-color="#c8bfe7" aria-label="Lavender"></button>
              </div>
              <button class="ribbon-btn ribbon-btn--compact" id="edit-colors" type="button">Edit colors</button>
            </div>
          </div>
          <div class="ribbon-title">Colors</div>
        </div>
      </div>

      <div class="paint-workspace">
        <div class="canvas-stage" id="canvas-stage" tabindex="0">
          <div class="canvas-wrap" id="canvas-wrap">
            <canvas id="paint-canvas" width="1200" height="720"></canvas>
            <div class="overlay-layer" id="overlay-layer">
              <div class="selection-box" id="selection-box"></div>
              <div class="selection-layer" id="selection-layer">
                <canvas id="selection-canvas"></canvas>
                <div class="selection-rotate" id="selection-rotate" title="Rotate"></div>
                <div class="selection-handle handle-nw" data-handle="nw"></div>
                <div class="selection-handle handle-n" data-handle="n"></div>
                <div class="selection-handle handle-ne" data-handle="ne"></div>
                <div class="selection-handle handle-e" data-handle="e"></div>
                <div class="selection-handle handle-se" data-handle="se"></div>
                <div class="selection-handle handle-s" data-handle="s"></div>
                <div class="selection-handle handle-sw" data-handle="sw"></div>
                <div class="selection-handle handle-w" data-handle="w"></div>
              </div>
              <div class="image-layer" id="image-layer">
                <img id="image-layer-img" alt="Placed image">
                <div class="image-handle handle-nw" data-handle="nw"></div>
                <div class="image-handle handle-n" data-handle="n"></div>
                <div class="image-handle handle-ne" data-handle="ne"></div>
                <div class="image-handle handle-e" data-handle="e"></div>
                <div class="image-handle handle-se" data-handle="se"></div>
                <div class="image-handle handle-s" data-handle="s"></div>
                <div class="image-handle handle-sw" data-handle="sw"></div>
                <div class="image-handle handle-w" data-handle="w"></div>
              </div>
              <textarea class="text-entry" id="text-entry" rows="2"></textarea>
            </div>
          </div>
        </div>
      </div>

      <div class="status-bar">
        <div class="status-left">
          <span id="status-tool">Tool: Brush</span>
          <span id="status-coords">x: 0, y: 0</span>
          <span id="status-size">Canvas: 1200 × 720</span>
        </div>
        <div class="status-right">
          <label class="zoom-control" for="zoom-range">
            <span>Zoom</span>
            <input id="zoom-range" type="range" min="50" max="200" value="100">
            <span class="zoom-pill" id="zoom-value">100%</span>
          </label>
        </div>
      </div>
    </div>
  </main>

  <script>
    (function () {
      var canvas = document.getElementById("paint-canvas");
      var ctx = canvas.getContext("2d");
      var canvasWrap = document.getElementById("canvas-wrap");
      var canvasStage = document.getElementById("canvas-stage");
      var overlayLayer = document.getElementById("overlay-layer");
      var selectionBox = document.getElementById("selection-box");
      var selectionLayer = document.getElementById("selection-layer");
      var selectionCanvas = document.getElementById("selection-canvas");
      var selectionCtx = selectionCanvas.getContext("2d");
      var selectionHandles = Array.prototype.slice.call(document.querySelectorAll(".selection-handle"));
      var selectionRotateHandle = document.getElementById("selection-rotate");
      var imageLayer = document.getElementById("image-layer");
      var imageLayerImg = document.getElementById("image-layer-img");
      var imageHandles = Array.prototype.slice.call(document.querySelectorAll(".image-handle"));
      var textEntry = document.getElementById("text-entry");

      var toolButtons = Array.prototype.slice.call(document.querySelectorAll("[data-tool]"));
      var outlineMode = document.getElementById("outline-mode");
      var fillMode = document.getElementById("fill-mode");
      var lineStyle = document.getElementById("line-style");
      var arrowHead = document.getElementById("arrow-head");
      var sizePicker = document.getElementById("size-picker");
      var opacityRange = document.getElementById("opacity-range");
      var color1Btn = document.getElementById("color1-btn");
      var color2Btn = document.getElementById("color2-btn");
      var color1Input = document.getElementById("color1-input");
      var color2Input = document.getElementById("color2-input");
      var paletteGrid = document.getElementById("palette-grid");
      var editColorsBtn = document.getElementById("edit-colors");
      var textSizeSelect = document.getElementById("text-size-select");
      var textSizeInput = document.getElementById("text-size-input");
      var textFont = document.getElementById("text-font");
      var imageScale = document.getElementById("image-scale");
      var applyImage = document.getElementById("apply-image");
      var cancelImage = document.getElementById("cancel-image");
      var canvasWidthInput = document.getElementById("canvas-width");
      var canvasHeightInput = document.getElementById("canvas-height");
      var resizeCanvasBtn = document.getElementById("resize-canvas");
      var cropBtn = document.getElementById("crop-btn");
      var rotateLeftBtn = document.getElementById("rotate-left");
      var rotateRightBtn = document.getElementById("rotate-right");
      var flipHBtn = document.getElementById("flip-h");
      var flipVBtn = document.getElementById("flip-v");
      var pasteBtn = document.getElementById("paste-btn");
      var cutBtn = document.getElementById("cut-btn");
      var copyBtn = document.getElementById("copy-btn");
      var undoBtn = document.getElementById("undo");
      var redoBtn = document.getElementById("redo");
      var savePngBtn = document.getElementById("save-png");
      var zoomRange = document.getElementById("zoom-range");
      var zoomValue = document.getElementById("zoom-value");
      var statusTool = document.getElementById("status-tool");
      var statusCoords = document.getElementById("status-coords");
      var statusSize = document.getElementById("status-size");

      var state = {
        tool: "brush",
        lineWidth: 2,
        opacity: 1,
        stroke: "#1f2937",
        fill: "#f97316",
        outlineMode: "solid",
        fillMode: "solid",
        lineStyle: "solid",
        arrowHead: "open",
        textSize: 28,
        textFont: "Segoe UI",
        zoom: 1,
        width: 1200,
        height: 720,
        fillTolerance: 40,
        pixelRatio: window.devicePixelRatio || 1,
        bg: "#ffffff",
        isDrawing: false,
        startX: 0,
        startY: 0,
        snapshot: null,
        history: [],
        historyIndex: -1,
        imagePlacement: null,
        imageDrag: null,
        imageResize: null,
        selection: null,
        selectionResize: null,
        selectionRotate: null,
        clipboardImage: null,
        cropMode: false,
        textFocusToken: 0
      };

      function getDevicePixelRatio() {
        return window.devicePixelRatio || 1;
      }

      function resizeCanvasBackingStore(width, height) {
        var dpr = getDevicePixelRatio();
        state.pixelRatio = dpr;
        canvas.width = Math.max(1, Math.round(width * dpr));
        canvas.height = Math.max(1, Math.round(height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function resizeSelectionCanvas(width, height) {
        var dpr = state.pixelRatio || 1;
        selectionCanvas.width = Math.max(1, Math.round(width * dpr));
        selectionCanvas.height = Math.max(1, Math.round(height * dpr));
      }

      function setCanvasSize(width, height, shouldScale, skipHistory) {
        var prevWidth = state.width;
        var prevHeight = state.height;
        var prevDpr = state.width ? canvas.width / state.width : (state.pixelRatio || 1);
        var temp = document.createElement("canvas");
        temp.width = Math.max(1, Math.round(prevWidth * prevDpr));
        temp.height = Math.max(1, Math.round(prevHeight * prevDpr));
        temp.getContext("2d").drawImage(canvas, 0, 0);

        resizeCanvasBackingStore(width, height);
        state.width = width;
        state.height = height;

        ctx.fillStyle = state.bg;
        ctx.fillRect(0, 0, width, height);

        if (temp.width && temp.height) {
          if (shouldScale) {
            ctx.drawImage(temp, 0, 0, temp.width, temp.height, 0, 0, width, height);
          } else {
            ctx.drawImage(temp, 0, 0, temp.width, temp.height, 0, 0, prevWidth, prevHeight);
          }
        }

        updateCanvasWrap();
        updateStatus();
        if (!skipHistory) {
          saveState();
        }
      }

      function updateCanvasWrap() {
        var cssWidth = state.width * state.zoom;
        var cssHeight = state.height * state.zoom;
        canvas.style.width = cssWidth + "px";
        canvas.style.height = cssHeight + "px";
        canvasWrap.style.width = cssWidth + "px";
        canvasWrap.style.height = cssHeight + "px";
        updateOverlayPositions();
      }

      function updateOverlayPositions() {
        if (state.selection) {
          updateSelectionLayer();
        }
        if (state.imagePlacement) {
          updateImageLayer();
        }
        if (textEntry.style.display === "block") {
          var cssScale = getCssScale();
          textEntry.style.fontSize = state.textSize * cssScale + "px";
        }
      }

      function syncTextEntrySize() {
        if (textEntry.style.display === "block") {
          var cssScale = getCssScale();
          textEntry.style.fontSize = state.textSize * cssScale + "px";
        }
      }

      function setTextSize(value, source) {
        var size = parseInt(value, 10);
        if (!size || size < 6) {
          size = 6;
        }
        if (size > 200) {
          size = 200;
        }
        state.textSize = size;
        if (source !== "input") {
          textSizeInput.value = size;
        }
        if (source !== "select") {
          var option = textSizeSelect.querySelector("option[value='" + size + "']");
          textSizeSelect.value = option ? String(size) : "custom";
        }
        syncTextEntrySize();
      }

      function getCssScale() {
        var rect = canvas.getBoundingClientRect();
        return rect.width / state.width;
      }

      function updateStatus() {
        statusTool.textContent = "Tool: " + state.tool.charAt(0).toUpperCase() + state.tool.slice(1);
        statusSize.textContent = "Canvas: " + state.width + " × " + state.height;
      }

      function getDefaultCanvasSize() {
        var stageRect = canvasStage.getBoundingClientRect();
        var availableWidth = Math.max(520, Math.floor(stageRect.width - 4));
        var availableHeight = Math.max(360, Math.floor(stageRect.height - 4));
        return { width: availableWidth, height: availableHeight };
      }

      function setTool(tool) {
        if (state.selection && state.tool === "select" && tool !== "select") {
          commitSelection();
        }
        state.tool = tool;
        if (tool === "filled-arrow") {
          state.arrowHead = "filled";
          arrowHead.value = "filled";
        }
        if (tool !== "select") {
          state.cropMode = false;
        }
        toolButtons.forEach(function (btn) {
          btn.classList.toggle("active", btn.dataset.tool === tool);
        });
        cropBtn.classList.toggle("active", state.cropMode);
        canvas.style.cursor = tool === "text" ? "text" : tool === "fill" ? "cell" : tool === "picker" ? "copy" : tool === "crop" ? "crosshair" : "crosshair";
        updateStatus();
      }

      function saveState() {
        var dataUrl = canvas.toDataURL("image/png");
        if (state.historyIndex < state.history.length - 1) {
          state.history = state.history.slice(0, state.historyIndex + 1);
        }
        state.history.push(dataUrl);
        if (state.history.length > 40) {
          state.history.shift();
        }
        state.historyIndex = state.history.length - 1;
        updateUndoRedo();
      }

      function restoreState(index) {
        if (index < 0 || index >= state.history.length) {
          return;
        }
        var img = new Image();
        img.onload = function () {
          ctx.clearRect(0, 0, state.width, state.height);
          ctx.fillStyle = state.bg;
          ctx.fillRect(0, 0, state.width, state.height);
          ctx.drawImage(img, 0, 0, state.width, state.height);
          state.historyIndex = index;
          updateUndoRedo();
        };
        img.src = state.history[index];
      }

      function updateUndoRedo() {
        undoBtn.disabled = state.historyIndex <= 0;
        redoBtn.disabled = state.historyIndex >= state.history.length - 1;
      }

      function getPoint(evt) {
        var rect = canvas.getBoundingClientRect();
        var scaleX = state.width / rect.width;
        var scaleY = state.height / rect.height;
        return {
          x: (evt.clientX - rect.left) * scaleX,
          y: (evt.clientY - rect.top) * scaleY
        };
      }

      function rgbaFromHex(hex, alpha) {
        var clean = hex.replace("#", "");
        if (clean.length === 3) {
          clean = clean[0] + clean[0] + clean[1] + clean[1] + clean[2] + clean[2];
        }
        var r = parseInt(clean.slice(0, 2), 16);
        var g = parseInt(clean.slice(2, 4), 16);
        var b = parseInt(clean.slice(4, 6), 16);
        return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
      }

      function rgbToHex(r, g, b) {
        return (
          "#" +
          [r, g, b]
            .map(function (val) {
              var hex = val.toString(16);
              return hex.length === 1 ? "0" + hex : hex;
            })
            .join("")
        );
      }

      function setColor1(hex) {
        state.stroke = hex;
        color1Input.value = hex;
        color1Btn.style.background = hex;
      }

      function setColor2(hex) {
        state.fill = hex;
        color2Input.value = hex;
        color2Btn.style.background = hex;
      }

      function beginStroke(point) {
        ctx.beginPath();
        ctx.moveTo(point.x, point.y);
      }

      function strokeTo(point) {
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = state.tool === "pencil" ? 2 : state.lineWidth;
        ctx.setLineDash([]);
        if (state.tool === "eraser") {
          ctx.strokeStyle = rgbaFromHex(state.bg, 1);
        } else {
          ctx.strokeStyle = rgbaFromHex(state.stroke, state.opacity);
        }
        ctx.lineTo(point.x, point.y);
        ctx.stroke();
      }

      function applyStrokeDash() {
        if (state.lineStyle === "dashed") {
          ctx.setLineDash([14, 8]);
          return;
        }
        if (state.lineStyle === "dotted") {
          ctx.setLineDash([2, 6]);
          return;
        }
        if (state.lineStyle === "dashdot") {
          ctx.setLineDash([14, 6, 2, 6]);
          return;
        }
        ctx.setLineDash([]);
      }

      function strokePathWithStyle() {
        applyStrokeDash();
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function strokeRectWithStyle(x, y, w, h) {
        applyStrokeDash();
        ctx.strokeRect(x, y, w, h);
        ctx.setLineDash([]);
      }

      function drawRoundRect(x, y, w, h, radius) {
        var r = Math.min(radius, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      function drawPolygon(sides, x, y, w, h) {
        var cx = x + w / 2;
        var cy = y + h / 2;
        var rx = w / 2;
        var ry = h / 2;
        ctx.beginPath();
        for (var i = 0; i < sides; i += 1) {
          var angle = (Math.PI * 2 * i) / sides - Math.PI / 2;
          var px = cx + Math.cos(angle) * rx;
          var py = cy + Math.sin(angle) * ry;
          if (i === 0) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }
        ctx.closePath();
      }

      function drawStar(x, y, w, h) {
        var cx = x + w / 2;
        var cy = y + h / 2;
        var outer = Math.min(w, h) / 2;
        var inner = outer * 0.45;
        ctx.beginPath();
        for (var i = 0; i < 10; i += 1) {
          var angle = (Math.PI / 5) * i - Math.PI / 2;
          var r = i % 2 === 0 ? outer : inner;
          var px = cx + Math.cos(angle) * r;
          var py = cy + Math.sin(angle) * r;
          if (i === 0) {
            ctx.moveTo(px, py);
          } else {
            ctx.lineTo(px, py);
          }
        }
        ctx.closePath();
      }

      function drawOpenArrowHead(tipX, tipY, dirX, dirY, headLength, headWidth) {
        var baseX = tipX - dirX * headLength;
        var baseY = tipY - dirY * headLength;
        var perpX = -dirY;
        var perpY = dirX;
        var wingX = perpX * headWidth * 0.5;
        var wingY = perpY * headWidth * 0.5;
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(baseX + wingX, baseY + wingY);
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(baseX - wingX, baseY - wingY);
        strokePathWithStyle();
      }

      function drawFilledArrowHead(tipX, tipY, dirX, dirY, headLength, headWidth) {
        var baseX = tipX - dirX * headLength;
        var baseY = tipY - dirY * headLength;
        var perpX = -dirY;
        var perpY = dirX;
        var wingX = perpX * headWidth * 0.5;
        var wingY = perpY * headWidth * 0.5;
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(baseX + wingX, baseY + wingY);
        ctx.lineTo(baseX - wingX, baseY - wingY);
        ctx.closePath();
        if (state.fillMode === "solid") {
          ctx.fill();
        }
        if (state.outlineMode !== "none") {
          strokePathWithStyle();
        }
      }

      function drawDiamondArrowHead(tipX, tipY, dirX, dirY, headLength, headWidth) {
        var baseX = tipX - dirX * headLength;
        var baseY = tipY - dirY * headLength;
        var midX = (tipX + baseX) / 2;
        var midY = (tipY + baseY) / 2;
        var perpX = -dirY;
        var perpY = dirX;
        var wingX = perpX * headWidth * 0.5;
        var wingY = perpY * headWidth * 0.5;
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(midX + wingX, midY + wingY);
        ctx.lineTo(baseX, baseY);
        ctx.lineTo(midX - wingX, midY - wingY);
        ctx.closePath();
        if (state.fillMode === "solid") {
          ctx.fill();
        }
        if (state.outlineMode !== "none") {
          strokePathWithStyle();
        }
      }

      function drawArrowHead(tipX, tipY, dirX, dirY, headLength, headWidth) {
        if (state.arrowHead === "filled") {
          drawFilledArrowHead(tipX, tipY, dirX, dirY, headLength, headWidth);
          return;
        }
        if (state.arrowHead === "diamond") {
          drawDiamondArrowHead(tipX, tipY, dirX, dirY, headLength, headWidth);
          return;
        }
        drawOpenArrowHead(tipX, tipY, dirX, dirY, headLength, headWidth);
      }

      function drawBlockArrow(startX, startY, endX, endY) {
        var dx = endX - startX;
        var dy = endY - startY;
        var len = Math.sqrt(dx * dx + dy * dy);
        if (len < 1) {
          return;
        }
        var dirX = dx / len;
        var dirY = dy / len;
        var shaftWidth = Math.max(2, state.lineWidth * 1.8);
        var headWidth = Math.max(6, shaftWidth * 2.1);
        var headLength = Math.min(Math.max(10, shaftWidth * 2.8), len * 0.55);
        if (len < headLength + 2) {
          headLength = len * 0.5;
        }
        var baseX = endX - dirX * headLength;
        var baseY = endY - dirY * headLength;
        var perpX = -dirY;
        var perpY = dirX;
        var shaftHalf = shaftWidth / 2;
        var headHalf = headWidth / 2;

        ctx.beginPath();
        ctx.moveTo(startX + perpX * shaftHalf, startY + perpY * shaftHalf);
        ctx.lineTo(baseX + perpX * shaftHalf, baseY + perpY * shaftHalf);
        ctx.lineTo(baseX + perpX * headHalf, baseY + perpY * headHalf);
        ctx.lineTo(endX, endY);
        ctx.lineTo(baseX - perpX * headHalf, baseY - perpY * headHalf);
        ctx.lineTo(baseX - perpX * shaftHalf, baseY - perpY * shaftHalf);
        ctx.lineTo(startX - perpX * shaftHalf, startY - perpY * shaftHalf);
        ctx.closePath();
        if (state.fillMode === "solid") {
          ctx.fill();
        }
        if (state.outlineMode !== "none") {
          strokePathWithStyle();
        }
      }

      function drawDirectionalArrow(startX, startY, endX, endY, doubleHead) {
        var dx = endX - startX;
        var dy = endY - startY;
        var len = Math.sqrt(dx * dx + dy * dy);
        if (len < 1) {
          return;
        }
        var dirX = dx / len;
        var dirY = dy / len;
        var headLength = Math.min(Math.max(12, state.lineWidth * 2.4), len * (doubleHead ? 0.33 : 0.48));
        var headWidth = Math.max(10, state.lineWidth * 2.1);
        var lineStartX = startX + (doubleHead ? dirX * headLength : 0);
        var lineStartY = startY + (doubleHead ? dirY * headLength : 0);
        var lineEndX = endX - dirX * headLength;
        var lineEndY = endY - dirY * headLength;

        ctx.lineWidth = Math.max(2, state.lineWidth * 0.8);
        ctx.beginPath();
        ctx.moveTo(lineStartX, lineStartY);
        ctx.lineTo(lineEndX, lineEndY);
        strokePathWithStyle();

        drawArrowHead(endX, endY, dirX, dirY, headLength, headWidth);
        if (doubleHead) {
          drawArrowHead(startX, startY, -dirX, -dirY, headLength, headWidth);
        }
      }

      function drawShape(point) {
        if (!state.snapshot) {
          return;
        }
        ctx.putImageData(state.snapshot, 0, 0);
        ctx.lineWidth = state.lineWidth;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = rgbaFromHex(state.stroke, state.opacity);
        ctx.fillStyle = rgbaFromHex(state.fill, state.opacity);

        if (state.tool === "line") {
          if (state.outlineMode === "none") {
            return;
          }
          ctx.beginPath();
          ctx.moveTo(state.startX, state.startY);
          ctx.lineTo(point.x, point.y);
          strokePathWithStyle();
          return;
        }

        var x = Math.min(state.startX, point.x);
        var y = Math.min(state.startY, point.y);
        var w = Math.abs(point.x - state.startX);
        var h = Math.abs(point.y - state.startY);

        if (state.tool === "rect") {
          if (state.fillMode === "solid") {
            ctx.fillRect(x, y, w, h);
          }
          if (state.outlineMode !== "none") {
            strokeRectWithStyle(x, y, w, h);
          }
          return;
        }

        if (state.tool === "roundrect") {
          drawRoundRect(x, y, w, h, Math.min(18, w / 5, h / 5));
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
          return;
        }

        if (state.tool === "ellipse") {
          ctx.beginPath();
          ctx.ellipse(x + w / 2, y + h / 2, Math.abs(w) / 2, Math.abs(h) / 2, 0, 0, Math.PI * 2);
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
          return;
        }

        if (state.tool === "triangle") {
          ctx.beginPath();
          ctx.moveTo(x + w / 2, y);
          ctx.lineTo(x + w, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
          return;
        }

        if (state.tool === "righttriangle") {
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + w, y + h);
          ctx.lineTo(x, y + h);
          ctx.closePath();
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
          return;
        }

        if (state.tool === "diamond") {
          ctx.beginPath();
          ctx.moveTo(x + w / 2, y);
          ctx.lineTo(x + w, y + h / 2);
          ctx.lineTo(x + w / 2, y + h);
          ctx.lineTo(x, y + h / 2);
          ctx.closePath();
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
          return;
        }

        if (state.tool === "pentagon") {
          drawPolygon(5, x, y, w, h);
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
          return;
        }

        if (state.tool === "hexagon") {
          drawPolygon(6, x, y, w, h);
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
          return;
        }

        if (state.tool === "arrow") {
          if (state.outlineMode !== "none") {
            drawDirectionalArrow(state.startX, state.startY, point.x, point.y, false);
          }
          return;
        }

        if (state.tool === "double-arrow") {
          if (state.outlineMode !== "none") {
            drawDirectionalArrow(state.startX, state.startY, point.x, point.y, true);
          }
          return;
        }

        if (state.tool === "filled-arrow") {
          if (state.outlineMode !== "none" || state.fillMode === "solid") {
            drawBlockArrow(state.startX, state.startY, point.x, point.y);
          }
          return;
        }

        if (state.tool === "star") {
          drawStar(x, y, w, h);
          if (state.fillMode === "solid") {
            ctx.fill();
          }
          if (state.outlineMode !== "none") {
            strokePathWithStyle();
          }
        }
      }

      function floodFill(point) {
        var dpr = state.pixelRatio || 1;
        var x = Math.floor(point.x * dpr);
        var y = Math.floor(point.y * dpr);
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var data = imageData.data;
        var width = canvas.width;
        var height = canvas.height;
        if (x < 0 || y < 0 || x >= width || y >= height) {
          return;
        }
        var index = (y * width + x) * 4;
        var target = [data[index], data[index + 1], data[index + 2], data[index + 3]];
        var fill = hexToRgbaArray(state.fill, state.opacity);
        var tolerance = state.fillTolerance || 32;
        if (colorsMatch(target, fill, 0)) {
          return;
        }
        var stack = [[x, y]];
        while (stack.length) {
          var item = stack.pop();
          var nx = item[0];
          var ny = item[1];
          if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
            continue;
          }
          var i = (ny * width + nx) * 4;
          var current = [data[i], data[i + 1], data[i + 2], data[i + 3]];
          if (!colorsMatch(current, target, tolerance)) {
            continue;
          }
          data[i] = fill[0];
          data[i + 1] = fill[1];
          data[i + 2] = fill[2];
          data[i + 3] = fill[3];
          stack.push([nx + 1, ny]);
          stack.push([nx - 1, ny]);
          stack.push([nx, ny + 1]);
          stack.push([nx, ny - 1]);
        }
        ctx.putImageData(imageData, 0, 0);
      }

      function hexToRgbaArray(hex, alpha) {
        var clean = hex.replace("#", "");
        if (clean.length === 3) {
          clean = clean[0] + clean[0] + clean[1] + clean[1] + clean[2] + clean[2];
        }
        var r = parseInt(clean.slice(0, 2), 16);
        var g = parseInt(clean.slice(2, 4), 16);
        var b = parseInt(clean.slice(4, 6), 16);
        return [r, g, b, Math.round(alpha * 255)];
      }

      function colorsMatch(a, b, tolerance) {
        var dr = Math.abs(a[0] - b[0]);
        var dg = Math.abs(a[1] - b[1]);
        var db = Math.abs(a[2] - b[2]);
        var da = Math.abs(a[3] - b[3]);
        var rgbMatch = (dr + dg + db) / 3 <= tolerance;
        var alphaMatch = da <= Math.max(40, tolerance * 2);
        return rgbMatch && alphaMatch;
      }

      function applyCropToSelection() {
        if (!state.selection) {
          return;
        }
        var w = state.selection.w;
        var h = state.selection.h;
        if (w < 5 || h < 5) {
          return;
        }
        var temp = document.createElement("canvas");
        temp.width = selectionCanvas.width;
        temp.height = selectionCanvas.height;
        temp.getContext("2d").drawImage(selectionCanvas, 0, 0);
        resizeCanvasBackingStore(w, h);
        state.width = w;
        state.height = h;
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(temp, 0, 0, temp.width, temp.height, 0, 0, w, h);
        selectionLayer.style.display = "none";
        state.selection = null;
        canvasWidthInput.value = w;
        canvasHeightInput.value = h;
        updateCanvasWrap();
        saveState();
        updateStatus();
      }

      function openTextInput(point) {
        textEntry.value = "";
        textEntry.style.display = "block";
        textEntry.dataset.x = point.x;
        textEntry.dataset.y = point.y;
        var cssScale = getCssScale();
        textEntry.style.left = point.x * cssScale + "px";
        textEntry.style.top = point.y * cssScale + "px";
        textEntry.style.fontSize = state.textSize * cssScale + "px";
        textEntry.style.fontFamily = state.textFont;
        var token = Date.now();
        state.textFocusToken = token;
        window.requestAnimationFrame(function () {
          if (state.textFocusToken !== token) {
            return;
          }
          if (typeof textEntry.focus === "function") {
            try {
              textEntry.focus({ preventScroll: true });
            } catch (err) {
              textEntry.focus();
            }
          }
          try {
            textEntry.setSelectionRange(0, textEntry.value.length);
          } catch (err) {}
        });
      }

      function commitText() {
        if (textEntry.style.display !== "block") {
          return;
        }
        state.textFocusToken = 0;
        var text = textEntry.value.trim();
        textEntry.style.display = "none";
        if (!text) {
          return;
        }
        var lines = text.split("\n");
        var x = parseFloat(textEntry.dataset.x || 0);
        var y = parseFloat(textEntry.dataset.y || 0);
        ctx.save();
        ctx.fillStyle = rgbaFromHex(state.stroke, state.opacity);
        ctx.font = state.textSize + "px " + state.textFont;
        ctx.textBaseline = "top";
        var lineHeight = state.textSize * 1.3;
        lines.forEach(function (line, idx) {
          ctx.fillText(line, x, y + idx * lineHeight);
        });
        ctx.restore();
        saveState();
      }

      function updateSelectionBox(rect) {
        var cssScale = getCssScale();
        selectionBox.style.left = rect.x * cssScale + "px";
        selectionBox.style.top = rect.y * cssScale + "px";
        selectionBox.style.width = rect.w * cssScale + "px";
        selectionBox.style.height = rect.h * cssScale + "px";
      }

      function updateSelectionLayer() {
        if (!state.selection) {
          return;
        }
        var cssScale = getCssScale();
        selectionLayer.style.left = state.selection.x * cssScale + "px";
        selectionLayer.style.top = state.selection.y * cssScale + "px";
        selectionLayer.style.width = state.selection.w * cssScale + "px";
        selectionLayer.style.height = state.selection.h * cssScale + "px";
      }

      function dismissSelectionOverlay() {
        selectionBox.style.display = "none";
        selectionLayer.style.display = "none";
        state.selection = null;
        state.selectionResize = null;
        state.selectionRotate = null;
      }

      function finalizeImagePlacementIfNeeded() {
        if (state.imagePlacement) {
          applyImagePlacement();
        }
      }

      function startSelection(point) {
        state.selection = {
          active: true,
          startX: point.x,
          startY: point.y,
          endX: point.x,
          endY: point.y,
          x: point.x,
          y: point.y,
          w: 0,
          h: 0,
          rotation: 0,
          moved: false,
          dragging: false
        };
        selectionBox.style.display = "block";
      }

      function updateSelection(point) {
        if (!state.selection) {
          return;
        }
        state.selection.endX = point.x;
        state.selection.endY = point.y;
        var rect = getSelectionRect();
        updateSelectionBox(rect);
      }

      function finalizeSelection() {
        if (!state.selection) {
          return;
        }
        var rect = getSelectionRect();
        if (rect.w < 5 || rect.h < 5) {
          selectionBox.style.display = "none";
          state.selection = null;
          return;
        }
        state.selection.x = rect.x;
        state.selection.y = rect.y;
        state.selection.w = rect.w;
        state.selection.h = rect.h;
        state.selection.rotation = 0;
        resizeSelectionCanvas(rect.w, rect.h);
        selectionCtx.setTransform(1, 0, 0, 1, 0, 0);
        selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
        var dpr = state.pixelRatio || 1;
        var imageData = ctx.getImageData(
          Math.round(rect.x * dpr),
          Math.round(rect.y * dpr),
          selectionCanvas.width,
          selectionCanvas.height
        );
        selectionCtx.putImageData(imageData, 0, 0);
        selectionLayer.style.display = "block";
        selectionBox.style.display = "none";
        updateSelectionLayer();
        if (state.cropMode) {
          applyCropToSelection();
          state.cropMode = false;
          cropBtn.classList.remove("active");
        }
      }

      function getSelectionRect() {
        var x1 = state.selection.startX;
        var y1 = state.selection.startY;
        var x2 = state.selection.endX;
        var y2 = state.selection.endY;
        return {
          x: Math.min(x1, x2),
          y: Math.min(y1, y2),
          w: Math.abs(x2 - x1),
          h: Math.abs(y2 - y1)
        };
      }

      function pointInSelection(point) {
        if (!state.selection) {
          return false;
        }
        return (
          point.x >= state.selection.x &&
          point.x <= state.selection.x + state.selection.w &&
          point.y >= state.selection.y &&
          point.y <= state.selection.y + state.selection.h
        );
      }

      function commitSelection() {
        if (!state.selection) {
          return;
        }
        ctx.drawImage(selectionCanvas, state.selection.x, state.selection.y, state.selection.w, state.selection.h);
        selectionLayer.style.display = "none";
        state.selection = null;
        state.selectionResize = null;
        saveState();
      }

      function clearSelectionArea() {
        if (!state.selection) {
          return;
        }
        ctx.fillStyle = state.bg;
        ctx.fillRect(state.selection.x, state.selection.y, state.selection.w, state.selection.h);
      }

      function deleteSelection() {
        if (!state.selection || selectionLayer.style.display !== "block") {
          return;
        }
        if (!state.selection.moved) {
          clearSelectionArea();
        }
        dismissSelectionOverlay();
        saveState();
      }

      function rotateSelectionFromSnapshot(delta, rotateState) {
        var baseWpx = rotateState.baseWpx;
        var baseHpx = rotateState.baseHpx;
        var cos = Math.cos(delta);
        var sin = Math.sin(delta);
        var newWpx = Math.max(1, Math.round(Math.abs(baseWpx * cos) + Math.abs(baseHpx * sin)));
        var newHpx = Math.max(1, Math.round(Math.abs(baseWpx * sin) + Math.abs(baseHpx * cos)));
        selectionCanvas.width = newWpx;
        selectionCanvas.height = newHpx;
        selectionCtx.setTransform(1, 0, 0, 1, 0, 0);
        selectionCtx.clearRect(0, 0, newWpx, newHpx);
        selectionCtx.translate(newWpx / 2, newHpx / 2);
        selectionCtx.rotate(delta);
        selectionCtx.drawImage(rotateState.snapshot, -baseWpx / 2, -baseHpx / 2);
        selectionCtx.setTransform(1, 0, 0, 1, 0, 0);

        var dpr = state.pixelRatio || 1;
        var newW = newWpx / dpr;
        var newH = newHpx / dpr;
        state.selection.w = newW;
        state.selection.h = newH;
        state.selection.x = rotateState.centerX - newW / 2;
        state.selection.y = rotateState.centerY - newH / 2;
        state.selection.rotation = rotateState.baseRotation + delta;
        updateSelectionLayer();
      }

      function rotateSelectionBy(delta) {
        if (!state.selection || selectionLayer.style.display !== "block") {
          return false;
        }
        if (!state.selection.moved) {
          clearSelectionArea();
          state.selection.moved = true;
        }
        var centerX = state.selection.x + state.selection.w / 2;
        var centerY = state.selection.y + state.selection.h / 2;
        var snapshot = document.createElement("canvas");
        snapshot.width = selectionCanvas.width;
        snapshot.height = selectionCanvas.height;
        snapshot.getContext("2d").drawImage(selectionCanvas, 0, 0);
        rotateSelectionFromSnapshot(delta, {
          baseWpx: selectionCanvas.width,
          baseHpx: selectionCanvas.height,
          snapshot: snapshot,
          centerX: centerX,
          centerY: centerY,
          baseRotation: state.selection.rotation || 0
        });
        return true;
      }

      function setupImagePlacement(img, options) {
        if (state.selection) {
          if (selectionLayer.style.display === "block") {
            commitSelection();
          } else {
            dismissSelectionOverlay();
          }
        }
        finalizeImagePlacementIfNeeded();
        if (options && options.preserveSize) {
          var nextWidth = Math.max(state.width, img.width);
          var nextHeight = Math.max(state.height, img.height);
          if (nextWidth !== state.width || nextHeight !== state.height) {
            setCanvasSize(nextWidth, nextHeight, false, false);
          }
        }
        state.imagePlacement = {
          img: img,
          baseWidth: img.width,
          baseHeight: img.height,
          width: img.width,
          height: img.height,
          scale: 1,
          x: Math.max(0, (state.width - img.width) / 2),
          y: Math.max(0, (state.height - img.height) / 2)
        };
        imageLayerImg.src = img.src;
        imageLayer.style.display = "block";
        if (imageScale) {
          imageScale.disabled = false;
          imageScale.value = 100;
        }
        if (applyImage) {
          applyImage.disabled = false;
        }
        if (cancelImage) {
          cancelImage.disabled = false;
        }
        updateImageLayer();
      }

      function updateImageLayer() {
        if (!state.imagePlacement) {
          return;
        }
        var placement = state.imagePlacement;
        var cssScale = getCssScale();
        imageLayer.style.left = placement.x * cssScale + "px";
        imageLayer.style.top = placement.y * cssScale + "px";
        imageLayer.style.width = placement.width * cssScale + "px";
        imageLayer.style.height = placement.height * cssScale + "px";
      }

      function applyImagePlacement() {
        if (!state.imagePlacement) {
          return;
        }
        var placement = state.imagePlacement;
        ctx.drawImage(placement.img, placement.x, placement.y, placement.width, placement.height);
        state.imagePlacement = null;
        imageLayer.style.display = "none";
        if (imageScale) {
          imageScale.disabled = true;
        }
        if (applyImage) {
          applyImage.disabled = true;
        }
        if (cancelImage) {
          cancelImage.disabled = true;
        }
        saveState();
      }

      function cancelImagePlacement() {
        state.imagePlacement = null;
        imageLayer.style.display = "none";
        if (imageScale) {
          imageScale.disabled = true;
        }
        if (applyImage) {
          applyImage.disabled = true;
        }
        if (cancelImage) {
          cancelImage.disabled = true;
        }
      }

      function handleImageFile(file, options) {
        var reader = new FileReader();
        reader.onload = function (event) {
          loadImageFromUrl(event.target.result, options);
        };
        reader.readAsDataURL(file);
      }

      function loadImageFromUrl(url, options) {
        var img = new Image();
        img.onload = function () {
          setupImagePlacement(img, options);
        };
        img.src = url;
      }

      function updateCoords(evt) {
        var point = getPoint(evt);
        statusCoords.textContent = "x: " + Math.round(point.x) + ", y: " + Math.round(point.y);
      }

      function pickColor(point, isSecondary) {
        var dpr = state.pixelRatio || 1;
        var x = Math.floor(point.x * dpr);
        var y = Math.floor(point.y * dpr);
        if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
          return;
        }
        var data = ctx.getImageData(x, y, 1, 1).data;
        var hex = rgbToHex(data[0], data[1], data[2]);
        if (isSecondary) {
          setColor2(hex);
        } else {
          setColor1(hex);
        }
      }

      function rotateCanvas(direction) {
        var temp = document.createElement("canvas");
        var tctx = temp.getContext("2d");
        if (direction === "left" || direction === "right") {
          temp.width = canvas.height;
          temp.height = canvas.width;
          tctx.translate(temp.width / 2, temp.height / 2);
          tctx.rotate(direction === "right" ? Math.PI / 2 : -Math.PI / 2);
          tctx.drawImage(canvas, -canvas.width / 2, -canvas.height / 2);
        }
        canvas.width = temp.width;
        canvas.height = temp.height;
        state.width = Math.round(temp.width / (state.pixelRatio || 1));
        state.height = Math.round(temp.height / (state.pixelRatio || 1));
        ctx.setTransform(state.pixelRatio || 1, 0, 0, state.pixelRatio || 1, 0, 0);
        ctx.clearRect(0, 0, state.width, state.height);
        ctx.drawImage(temp, 0, 0, temp.width, temp.height, 0, 0, state.width, state.height);
        canvasWidthInput.value = state.width;
        canvasHeightInput.value = state.height;
        updateCanvasWrap();
        saveState();
        updateStatus();
      }

      function flipCanvas(direction) {
        var temp = document.createElement("canvas");
        temp.width = canvas.width;
        temp.height = canvas.height;
        var tctx = temp.getContext("2d");
        if (direction === "horizontal") {
          tctx.translate(temp.width, 0);
          tctx.scale(-1, 1);
        } else {
          tctx.translate(0, temp.height);
          tctx.scale(1, -1);
        }
        tctx.drawImage(canvas, 0, 0);
        ctx.clearRect(0, 0, state.width, state.height);
        ctx.drawImage(temp, 0, 0, temp.width, temp.height, 0, 0, state.width, state.height);
        saveState();
      }

      function getSelectionDataUrl() {
        if (state.selection) {
          var temp = document.createElement("canvas");
          temp.width = selectionCanvas.width;
          temp.height = selectionCanvas.height;
          var tctx = temp.getContext("2d");
          tctx.drawImage(selectionCanvas, 0, 0);
          return temp.toDataURL("image/png");
        }
        return canvas.toDataURL("image/png");
      }

      function handleCopy() {
        finalizeImagePlacementIfNeeded();
        var dataUrl = getSelectionDataUrl();
        state.clipboardImage = dataUrl;
        writeImageToClipboard(dataUrl);
      }

      function handleCut() {
        finalizeImagePlacementIfNeeded();
        if (state.selection) {
          handleCopy();
          clearSelectionArea();
          selectionLayer.style.display = "none";
          state.selection = null;
          saveState();
        } else {
          handleCopy();
          ctx.fillStyle = state.bg;
          ctx.fillRect(0, 0, state.width, state.height);
          saveState();
        }
      }

      function writeImageToClipboard(dataUrl) {
        if (!navigator.clipboard || !navigator.clipboard.write) {
          return;
        }
        fetch(dataUrl)
          .then(function (res) {
            return res.blob();
          })
          .then(function (blob) {
            var item = new ClipboardItem({ "image/png": blob });
            return navigator.clipboard.write([item]);
          })
          .catch(function () {});
      }

      function handlePasteButton() {
        finalizeImagePlacementIfNeeded();
        if (navigator.clipboard && navigator.clipboard.read) {
          navigator.clipboard
            .read()
            .then(function (items) {
              for (var i = 0; i < items.length; i += 1) {
                var item = items[i];
                for (var j = 0; j < item.types.length; j += 1) {
                  if (item.types[j].indexOf("image") === 0) {
                    return item.getType(item.types[j]).then(function (blob) {
                      var url = URL.createObjectURL(blob);
                      loadImageFromUrl(url, { preserveSize: true });
                      return;
                    });
                  }
                }
              }
              if (state.clipboardImage) {
                loadImageFromUrl(state.clipboardImage, { preserveSize: true });
              } else {
                alert("Paste an image with Cmd+V (Mac) or Ctrl+V (Windows). Clipboard access may be blocked by your browser.");
              }
            })
            .catch(function () {
              if (state.clipboardImage) {
                loadImageFromUrl(state.clipboardImage, { preserveSize: true });
              } else {
                alert("Paste an image with Cmd+V (Mac) or Ctrl+V (Windows). Clipboard access may be blocked by your browser.");
              }
            });
        } else if (state.clipboardImage) {
          loadImageFromUrl(state.clipboardImage, { preserveSize: true });
        } else {
          alert("Paste an image with Cmd+V (Mac) or Ctrl+V (Windows). Clipboard access may be blocked by your browser.");
        }
      }

      toolButtons.forEach(function (btn) {
        btn.addEventListener("click", function () {
          finalizeImagePlacementIfNeeded();
          setTool(btn.dataset.tool);
        });
      });

      sizePicker.addEventListener("click", function (evt) {
        var target = evt.target;
        if (target && target.dataset.size) {
          state.lineWidth = parseInt(target.dataset.size, 10);
          Array.prototype.slice.call(sizePicker.querySelectorAll(".size-btn")).forEach(function (btn) {
            btn.classList.toggle("active", btn === target);
          });
        }
      });

      opacityRange.addEventListener("input", function () {
        state.opacity = parseInt(opacityRange.value, 10) / 100;
      });

      outlineMode.addEventListener("change", function () {
        state.outlineMode = outlineMode.value;
      });

      fillMode.addEventListener("change", function () {
        state.fillMode = fillMode.value;
      });

      lineStyle.addEventListener("change", function () {
        state.lineStyle = lineStyle.value;
      });

      arrowHead.addEventListener("change", function () {
        state.arrowHead = arrowHead.value;
      });

      color1Btn.addEventListener("click", function () {
        color1Input.click();
      });

      color2Btn.addEventListener("click", function () {
        color2Input.click();
      });

      color1Input.addEventListener("input", function () {
        setColor1(color1Input.value);
      });

      color2Input.addEventListener("input", function () {
        setColor2(color2Input.value);
      });

      paletteGrid.addEventListener("click", function (evt) {
        var target = evt.target;
        if (target && target.dataset.color) {
          setColor1(target.dataset.color);
        }
      });

      paletteGrid.addEventListener("contextmenu", function (evt) {
        var target = evt.target;
        if (target && target.dataset.color) {
          evt.preventDefault();
          setColor2(target.dataset.color);
        }
      });

      editColorsBtn.addEventListener("click", function () {
        color1Input.click();
      });

      textSizeSelect.addEventListener("change", function () {
        if (textSizeSelect.value === "custom") {
          textSizeInput.focus();
          textSizeInput.select();
          return;
        }
        setTextSize(textSizeSelect.value, "select");
      });

      textSizeInput.addEventListener("input", function () {
        if (!textSizeInput.value) {
          return;
        }
        setTextSize(textSizeInput.value, "input");
      });

      textSizeInput.addEventListener("change", function () {
        if (!textSizeInput.value) {
          return;
        }
        setTextSize(textSizeInput.value, "input");
      });

      textFont.addEventListener("change", function () {
        state.textFont = textFont.value;
      });

      if (imageScale) {
        imageScale.addEventListener("input", function () {
          if (!state.imagePlacement) {
            return;
          }
          state.imagePlacement.scale = parseInt(imageScale.value, 10) / 100;
          state.imagePlacement.width = state.imagePlacement.baseWidth * state.imagePlacement.scale;
          state.imagePlacement.height = state.imagePlacement.baseHeight * state.imagePlacement.scale;
          updateImageLayer();
        });
      }

      if (applyImage) {
        applyImage.addEventListener("click", applyImagePlacement);
      }
      if (cancelImage) {
        cancelImage.addEventListener("click", cancelImagePlacement);
      }

      resizeCanvasBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        var newWidth = parseInt(canvasWidthInput.value, 10);
        var newHeight = parseInt(canvasHeightInput.value, 10);
        if (!newWidth || !newHeight) {
          return;
        }
        setCanvasSize(newWidth, newHeight, true, false);
      });

      function handleResizeKey(evt) {
        if (evt.key === "Enter") {
          resizeCanvasBtn.click();
        }
      }

      canvasWidthInput.addEventListener("keydown", handleResizeKey);
      canvasHeightInput.addEventListener("keydown", handleResizeKey);

      cropBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        if (state.selection) {
          applyCropToSelection();
        } else {
          state.cropMode = true;
          setTool("select");
        }
      });

      rotateLeftBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        if (!rotateSelectionBy(-Math.PI / 2)) {
          rotateCanvas("left");
        }
      });

      rotateRightBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        if (!rotateSelectionBy(Math.PI / 2)) {
          rotateCanvas("right");
        }
      });

      flipHBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        flipCanvas("horizontal");
      });

      flipVBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        flipCanvas("vertical");
      });

      if (pasteBtn) {
        pasteBtn.addEventListener("click", handlePasteButton);
      }
      if (copyBtn) {
        copyBtn.addEventListener("click", handleCopy);
      }
      if (cutBtn) {
        cutBtn.addEventListener("click", handleCut);
      }

      undoBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        restoreState(state.historyIndex - 1);
      });

      redoBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        restoreState(state.historyIndex + 1);
      });

      savePngBtn.addEventListener("click", function () {
        finalizeImagePlacementIfNeeded();
        var link = document.createElement("a");
        link.download = "painter.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      });

      zoomRange.addEventListener("input", function () {
        state.zoom = parseInt(zoomRange.value, 10) / 100;
        zoomValue.textContent = Math.round(state.zoom * 100) + "%";
        updateCanvasWrap();
      });

      canvas.addEventListener("contextmenu", function (evt) {
        evt.preventDefault();
      });

      canvas.addEventListener("pointerdown", function (evt) {
        if (state.imagePlacement) {
          finalizeImagePlacementIfNeeded();
        }
        if (textEntry.style.display === "block") {
          commitText();
        }
        var point = getPoint(evt);
        if (state.tool === "select") {
          if (state.selection && pointInSelection(point)) {
            return;
          }
          if (state.selection) {
            commitSelection();
          }
          startSelection(point);
          state.isDrawing = true;
          return;
        }
        if (state.tool === "picker") {
          pickColor(point, evt.button === 2 || evt.buttons === 2);
          return;
        }
        if (state.tool === "text") {
          openTextInput(point);
          return;
        }
        if (state.tool === "fill") {
          floodFill(point);
          saveState();
          return;
        }
        state.isDrawing = true;
        state.startX = point.x;
        state.startY = point.y;
        if (state.tool === "brush" || state.tool === "pencil" || state.tool === "eraser") {
          beginStroke(point);
        } else {
          state.snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      });

      canvas.addEventListener("pointermove", function (evt) {
        updateCoords(evt);
        if (!state.isDrawing) {
          return;
        }
        var point = getPoint(evt);
        if (state.tool === "select") {
          updateSelection(point);
          return;
        }
        if (state.tool === "brush" || state.tool === "pencil" || state.tool === "eraser") {
          strokeTo(point);
          return;
        }
        drawShape(point);
      });

      canvas.addEventListener("pointerup", function () {
        if (!state.isDrawing) {
          return;
        }
        state.isDrawing = false;
        if (state.tool === "select") {
          finalizeSelection();
          return;
        }
        if (state.tool === "brush" || state.tool === "pencil" || state.tool === "eraser" || state.tool === "line" || state.tool === "rect" || state.tool === "ellipse" || state.tool === "roundrect" || state.tool === "triangle" || state.tool === "righttriangle" || state.tool === "diamond" || state.tool === "pentagon" || state.tool === "hexagon" || state.tool === "arrow" || state.tool === "double-arrow" || state.tool === "filled-arrow" || state.tool === "star") {
          saveState();
        }
        state.snapshot = null;
      });

      canvas.addEventListener("pointerleave", function () {
        if (state.isDrawing && (state.tool === "brush" || state.tool === "pencil" || state.tool === "eraser")) {
          saveState();
          state.isDrawing = false;
        }
      });

      selectionLayer.addEventListener("pointerdown", function (evt) {
        if (!state.selection) {
          return;
        }
        if (evt.button !== 0) {
          return;
        }
        evt.preventDefault();
        var point = getPoint(evt);
        state.selection.dragging = true;
        state.selection.dragOffsetX = point.x - state.selection.x;
        state.selection.dragOffsetY = point.y - state.selection.y;
        selectionLayer.setPointerCapture(evt.pointerId);
      });

      selectionLayer.addEventListener("pointermove", function (evt) {
        if (!state.selection || !state.selection.dragging || state.selectionResize) {
          return;
        }
        var point = getPoint(evt);
        if (!state.selection.moved) {
          clearSelectionArea();
          state.selection.moved = true;
        }
        state.selection.x = point.x - state.selection.dragOffsetX;
        state.selection.y = point.y - state.selection.dragOffsetY;
        updateSelectionLayer();
      });

      selectionLayer.addEventListener("pointerup", function () {
        if (state.selection) {
          state.selection.dragging = false;
        }
      });

      selectionHandles.forEach(function (handle) {
        handle.addEventListener("pointerdown", function (evt) {
          if (!state.selection) {
            return;
          }
          if (evt.button !== 0) {
            return;
          }
          evt.preventDefault();
          evt.stopPropagation();
          var point = getPoint(evt);
          var snapshot = document.createElement("canvas");
          snapshot.width = selectionCanvas.width;
          snapshot.height = selectionCanvas.height;
          snapshot.getContext("2d").drawImage(selectionCanvas, 0, 0);
          state.selectionResize = {
            handle: handle.dataset.handle,
            startX: point.x,
            startY: point.y,
            originX: state.selection.x,
            originY: state.selection.y,
            originW: state.selection.w,
            originH: state.selection.h,
            snapshot: snapshot
          };
          handle.setPointerCapture(evt.pointerId);
        });

        handle.addEventListener("pointermove", function (evt) {
          if (!state.selectionResize || !state.selection || state.selectionResize.handle !== handle.dataset.handle) {
            return;
          }
          evt.preventDefault();
          var resize = state.selectionResize;
          var point = getPoint(evt);
          var dx = point.x - resize.startX;
          var dy = point.y - resize.startY;
          var minSize = 12;
          var newX = resize.originX;
          var newY = resize.originY;
          var newW = resize.originW;
          var newH = resize.originH;

          switch (resize.handle) {
            case "se":
              newW = resize.originW + dx;
              newH = resize.originH + dy;
              break;
            case "sw":
              newW = resize.originW - dx;
              newH = resize.originH + dy;
              newX = resize.originX + dx;
              break;
            case "ne":
              newW = resize.originW + dx;
              newH = resize.originH - dy;
              newY = resize.originY + dy;
              break;
            case "nw":
              newW = resize.originW - dx;
              newH = resize.originH - dy;
              newX = resize.originX + dx;
              newY = resize.originY + dy;
              break;
            case "e":
              newW = resize.originW + dx;
              break;
            case "w":
              newW = resize.originW - dx;
              newX = resize.originX + dx;
              break;
            case "s":
              newH = resize.originH + dy;
              break;
            case "n":
              newH = resize.originH - dy;
              newY = resize.originY + dy;
              break;
            default:
              break;
          }

          if (evt.shiftKey && resize.originW && resize.originH) {
            var ratio = resize.originW / resize.originH;
            if (newW / newH > ratio) {
              newW = newH * ratio;
            } else {
              newH = newW / ratio;
            }
            if (resize.handle.indexOf("w") !== -1) {
              newX = resize.originX + (resize.originW - newW);
            }
            if (resize.handle.indexOf("n") !== -1) {
              newY = resize.originY + (resize.originH - newH);
            }
          }

          if (newW < minSize) {
            newW = minSize;
            if (resize.handle.indexOf("w") !== -1) {
              newX = resize.originX + (resize.originW - minSize);
            }
          }
          if (newH < minSize) {
            newH = minSize;
            if (resize.handle.indexOf("n") !== -1) {
              newY = resize.originY + (resize.originH - minSize);
            }
          }

          if (!state.selection.moved) {
            clearSelectionArea();
            state.selection.moved = true;
          }

          state.selection.x = newX;
          state.selection.y = newY;
          state.selection.w = newW;
          state.selection.h = newH;

          resizeSelectionCanvas(newW, newH);
          selectionCtx.setTransform(1, 0, 0, 1, 0, 0);
          selectionCtx.clearRect(0, 0, selectionCanvas.width, selectionCanvas.height);
          selectionCtx.drawImage(
            resize.snapshot,
            0,
            0,
            resize.snapshot.width,
            resize.snapshot.height,
            0,
            0,
            selectionCanvas.width,
            selectionCanvas.height
          );
          updateSelectionLayer();
        });

        handle.addEventListener("pointerup", function () {
          if (state.selectionResize && state.selectionResize.handle === handle.dataset.handle) {
            state.selectionResize = null;
          }
        });
      });

      if (selectionRotateHandle) {
        selectionRotateHandle.addEventListener("pointerdown", function (evt) {
          if (!state.selection) {
            return;
          }
          if (evt.button !== 0) {
            return;
          }
          evt.preventDefault();
          evt.stopPropagation();
          if (!state.selection.moved) {
            clearSelectionArea();
            state.selection.moved = true;
          }
          var point = getPoint(evt);
          var centerX = state.selection.x + state.selection.w / 2;
          var centerY = state.selection.y + state.selection.h / 2;
          var snapshot = document.createElement("canvas");
          snapshot.width = selectionCanvas.width;
          snapshot.height = selectionCanvas.height;
          snapshot.getContext("2d").drawImage(selectionCanvas, 0, 0);
          state.selectionRotate = {
            startAngle: Math.atan2(point.y - centerY, point.x - centerX),
            centerX: centerX,
            centerY: centerY,
            snapshot: snapshot,
            baseWpx: selectionCanvas.width,
            baseHpx: selectionCanvas.height,
            baseRotation: state.selection.rotation || 0
          };
          selectionRotateHandle.setPointerCapture(evt.pointerId);
        });

        selectionRotateHandle.addEventListener("pointermove", function (evt) {
          if (!state.selectionRotate || !state.selection) {
            return;
          }
          evt.preventDefault();
          var point = getPoint(evt);
          var angle = Math.atan2(point.y - state.selectionRotate.centerY, point.x - state.selectionRotate.centerX);
          var delta = angle - state.selectionRotate.startAngle;
          rotateSelectionFromSnapshot(delta, state.selectionRotate);
        });

        selectionRotateHandle.addEventListener("pointerup", function () {
          state.selectionRotate = null;
        });
      }

      imageLayer.addEventListener("pointerdown", function (evt) {
        if (!state.imagePlacement || (evt.target && evt.target.classList.contains("image-handle"))) {
          return;
        }
        evt.preventDefault();
        var point = getPoint(evt);
        state.imageDrag = {
          startX: point.x,
          startY: point.y,
          originX: state.imagePlacement.x,
          originY: state.imagePlacement.y
        };
        imageLayer.setPointerCapture(evt.pointerId);
      });

      imageLayer.addEventListener("pointermove", function (evt) {
        if (!state.imageDrag || !state.imagePlacement) {
          return;
        }
        var point = getPoint(evt);
        var dx = point.x - state.imageDrag.startX;
        var dy = point.y - state.imageDrag.startY;
        state.imagePlacement.x = state.imageDrag.originX + dx;
        state.imagePlacement.y = state.imageDrag.originY + dy;
        updateImageLayer();
      });

      imageLayer.addEventListener("pointerup", function () {
        state.imageDrag = null;
      });

      imageHandles.forEach(function (handle) {
        handle.addEventListener("pointerdown", function (evt) {
          if (!state.imagePlacement) {
            return;
          }
          evt.preventDefault();
          evt.stopPropagation();
          var point = getPoint(evt);
          state.imageResize = {
            handle: handle.dataset.handle,
            startX: point.x,
            startY: point.y,
            originX: state.imagePlacement.x,
            originY: state.imagePlacement.y,
            originW: state.imagePlacement.width,
            originH: state.imagePlacement.height
          };
          handle.setPointerCapture(evt.pointerId);
        });

        handle.addEventListener("pointermove", function (evt) {
          if (!state.imageResize || !state.imagePlacement) {
            return;
          }
          evt.preventDefault();
          var resize = state.imageResize;
          var point = getPoint(evt);
          var dx = point.x - resize.startX;
          var dy = point.y - resize.startY;
          var minSize = 24;
          var newX = resize.originX;
          var newY = resize.originY;
          var newW = resize.originW;
          var newH = resize.originH;

          switch (resize.handle) {
            case "se":
              newW = resize.originW + dx;
              newH = resize.originH + dy;
              break;
            case "sw":
              newW = resize.originW - dx;
              newH = resize.originH + dy;
              newX = resize.originX + dx;
              break;
            case "ne":
              newW = resize.originW + dx;
              newH = resize.originH - dy;
              newY = resize.originY + dy;
              break;
            case "nw":
              newW = resize.originW - dx;
              newH = resize.originH - dy;
              newX = resize.originX + dx;
              newY = resize.originY + dy;
              break;
            case "e":
              newW = resize.originW + dx;
              break;
            case "w":
              newW = resize.originW - dx;
              newX = resize.originX + dx;
              break;
            case "s":
              newH = resize.originH + dy;
              break;
            case "n":
              newH = resize.originH - dy;
              newY = resize.originY + dy;
              break;
            default:
              break;
          }

          if ((evt.shiftKey || resize.handle.length === 2) && resize.originW && resize.originH) {
            var ratio = resize.originW / resize.originH;
            if (newW / newH > ratio) {
              newW = newH * ratio;
            } else {
              newH = newW / ratio;
            }
            if (resize.handle.indexOf("w") !== -1) {
              newX = resize.originX + (resize.originW - newW);
            }
            if (resize.handle.indexOf("n") !== -1) {
              newY = resize.originY + (resize.originH - newH);
            }
          }

          if (newW < minSize) {
            newW = minSize;
            if (resize.handle.indexOf("w") !== -1) {
              newX = resize.originX + (resize.originW - minSize);
            }
          }
          if (newH < minSize) {
            newH = minSize;
            if (resize.handle.indexOf("n") !== -1) {
              newY = resize.originY + (resize.originH - minSize);
            }
          }

          state.imagePlacement.x = newX;
          state.imagePlacement.y = newY;
          state.imagePlacement.width = newW;
          state.imagePlacement.height = newH;
          state.imagePlacement.scale = newW / state.imagePlacement.baseWidth;
          if (imageScale) {
            var sliderValue = Math.round(state.imagePlacement.scale * 100);
            var sliderMin = parseInt(imageScale.min, 10);
            var sliderMax = parseInt(imageScale.max, 10);
            sliderValue = Math.max(sliderMin, Math.min(sliderMax, sliderValue));
            imageScale.value = sliderValue;
          }
          updateImageLayer();
        });

        handle.addEventListener("pointerup", function () {
          state.imageResize = null;
        });
      });

      textEntry.addEventListener("keydown", function (evt) {
        if (evt.key === "Enter" && !evt.shiftKey) {
          evt.preventDefault();
          commitText();
        }
        if (evt.key === "Escape") {
          textEntry.style.display = "none";
        }
      });

      textEntry.addEventListener("blur", function () {
        window.setTimeout(function () {
          if (textEntry.style.display === "block" && document.activeElement !== textEntry) {
            commitText();
          }
        }, 0);
      });

      textEntry.addEventListener("pointerdown", function (evt) {
        evt.stopPropagation();
      });

      textEntry.addEventListener("click", function (evt) {
        evt.stopPropagation();
      });

      document.addEventListener("keydown", function (evt) {
        var target = evt.target;
        var tag = target && target.tagName ? target.tagName.toLowerCase() : "";
        var isEditable =
          tag === "input" ||
          tag === "textarea" ||
          tag === "select" ||
          (target && target.isContentEditable);
        var isModifier = evt.metaKey || evt.ctrlKey;
        if (isModifier && evt.key.toLowerCase() === "z") {
          evt.preventDefault();
          if (evt.shiftKey) {
            restoreState(state.historyIndex + 1);
          } else {
            restoreState(state.historyIndex - 1);
          }
          return;
        }
        if (!isEditable && textEntry.style.display !== "block" && (evt.key === "Delete" || evt.key === "Backspace")) {
          if (state.selection && selectionLayer.style.display === "block") {
            evt.preventDefault();
            deleteSelection();
          }
        }
      });

      document.addEventListener("paste", function (evt) {
        finalizeImagePlacementIfNeeded();
        var items = evt.clipboardData && evt.clipboardData.items;
        if (!items) {
          return;
        }
        for (var i = 0; i < items.length; i += 1) {
          var item = items[i];
          if (item.type.indexOf("image") === 0) {
            var file = item.getAsFile();
            if (file) {
              handleImageFile(file, { preserveSize: true });
              evt.preventDefault();
              return;
            }
          }
        }
      });

      canvasStage.addEventListener("dragover", function (evt) {
        evt.preventDefault();
      });

      canvasStage.addEventListener("drop", function (evt) {
        evt.preventDefault();
        if (evt.dataTransfer && evt.dataTransfer.files && evt.dataTransfer.files[0]) {
          handleImageFile(evt.dataTransfer.files[0]);
        }
      });

      setColor1(state.stroke);
      setColor2(state.fill);
      setTextSize(state.textSize, "init");
      sizePicker.querySelector(".size-btn[data-size='2']").classList.add("active");

      window.setTimeout(function () {
        var initialSize = getDefaultCanvasSize();
        canvasWidthInput.value = initialSize.width;
        canvasHeightInput.value = initialSize.height;
        setCanvasSize(initialSize.width, initialSize.height, false, true);
        saveState();
        updateStatus();
        updateCanvasWrap();
      }, 0);

      window.addEventListener("resize", function () {
        var next = getDevicePixelRatio();
        if (next !== state.pixelRatio) {
          setCanvasSize(state.width, state.height, false, true);
        }
      });
    })();
  </script>
</body>
</html>
